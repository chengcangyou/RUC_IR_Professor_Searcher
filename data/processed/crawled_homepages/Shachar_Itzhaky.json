{
  "name": "Shachar Itzhaky",
  "homepage": "https://csaws.cs.technion.ac.il/~shachari",
  "status": "success",
  "content": "Shachar Itzhaky (Technion) Shachar Itzhaky A Minimalist Web Page me Well, Hi. I am an associate professor at Technion, Haifa. My research areas include functional languages, synthesis of functional programs, and high-level programming. This is my current research statement. Publications Easter Egg: Equality Reasoning Based on E-Graphs with Multiple Assumptions   Eytan Singher, Shachar Itzhaky. In FMCAD 2024 (Formal Methods in Computer-Aided Design, October 2024) Hyperproperty Verification as CHC Satisfiability   Shachar Itzhaky, Sharon Shoham, Yakir Vizel. In ESOP 2024 (European Symposium on Programming, April 2024) Leveraging Rust Types for Program Synthesis Abstract  Jonás Fiala, Shachar Itzhaky, Peter Müller, Nadia Polikarpova, Ilya Sergey. In Proc. ACM Program. Lang. 2023 The problem of automatically proving the equality of terms over recursive functions and inductive data types is challenging, as such proofs often require auxiliary lemmas which must themselves be proven. Previous attempts at lemma discovery compromise on either efficiency or efficacy. Goal-directed approaches are fast but limited in expressiveness, as they can only discover auxiliary lemmas which entail their goals. Theory exploration approaches are expressive but inefficient, as they exhaustively enumerate candidate lemmas.We introduce e-graph guided lemma discovery, a new approach to finding equational proofs that makes theory exploration goal-directed. We accomplish this by using e-graphs and equality saturation to efficiently construct and compactly represent the space of all goal-oriented proofs. This allows us to explore only those auxiliary lemmas guaranteed to help make progress on some of these proofs. We implemented our method in a new prover called and compared it with three state-of-the-art provers across a variety of benchmarks. performs consistently well on two standard benchmarks and additionally solves 50 a new challenging set.SMT Sampling via Model-Guided Approximation   Matan Peled, Bat-Chen Rothenberg, Shachar Itzhaky. In Formal Methods - 25th International Symposium, FM 2023 Scalable Spreadsheet-Driven End-User Applications with Incremental Computation   Sean Hadar, Shachar Itzhaky. In Onward! 2023 (ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software, Onward!, October 2023) AmiGo: Computational Design of Amigurumi Crochet Patterns   Michal Edelstein, Hila Peleg, Shachar Itzhaky, Mirela Ben-Chen. In SCF '22: Proceedings of the 7th Annual ACM Symposium on Computational Fabrication, Seattle, WA, USA, October 26-28, 2022 Run-Time Complexity Bounds Using Squeezers Abstract  Oren Ish-Shalom, Shachar Itzhaky, Noam Rinetzky, Sharon Shoham. In ESOP 2021 (European Symposium on Programming, March 2021) Determining upper bounds on the time complexity of a program is a fundamental problem with a variety of applications, such as performance debugging, resource certification, and compile-time optimizations. Automated techniques for cost analysis excel at bounding the resource complexity of programs that use integer values and linear arithmetic. Unfortunately, they fall short when execution traces become more involved, esp. when data dependencies may affect the termination conditions of loops. In such cases, state-of-the-art analyzers have shown to produce loose bounds, or even no bound at all.We propose a novel technique that generalizes the common notion of recurrence relations based on ranking functions. Existing methods usually unfold one loop iteration, and examine the resulting relations between variables. These relations assist in establishing a recurrence that bounds the number of loop iterations. We propose a different approach, where we derive recurrences by comparing whole traces with whole traces of a lower rank, avoiding the need to analyze the complexity of intermediate states. We offer a set of global properties, defined with respect to whole traces, that facilitate such a comparison, and show that these properties can be checked efficiently using a handful of local conditions. To this end, we adapt state squeezers, an induction mechanism previously used for verifying safety properties. We demonstrate that this technique encompasses the reasoning power of bounded unfolding, and more. We present some seemingly innocuous, yet intricate, examples where previous tools based on cost relations and control flow analysis fail to solve, and that our squeezer-powered approach succeeds.Programming by Predicates: a Formal Model for Interactive Synthesis   Hila Peleg, Shachar Itzhaky, Sharon Shoham, Eran Yahav. In Acta Informatica 2020 Liquid Information Flow Control Abstract  Nadia Polikarpova, Deian Stefan, Jean Yang, Shachar Itzhaky, Travis Hance, Armando Solar-Lezama. In ICFP 2020 (ACM SIGPLAN International Conference on Functional Programming, August 2020) We present Lifty, a domain-specific language for data-centric applications that manipulate sensitive data. A Lifty programmer annotates the sources of sensitive data with declarative security policies, and the language statically and automatically verifies that the application handles the data according to the policies. Moreover, if verification fails, Lifty suggests a provably correct repair, thereby easing the programmer burden of implementing policy enforcing code throughout the application.The main insight behind Lifty is to encode information flow control using liquid types, an expressive yet decidable type system. Liquid types enable fully automatic checking of complex, data dependent policies, and power our repair mechanism via type-driven error localization and patch synthesis. Our experience using Lifty to implement three case studies from the literature shows that ◦ the Lifty policy language is sufficiently expressive to specify many real-world policies, ◦ the Lifty type checker is able to verify secure programs and find leaks in insecure programs quickly, and ◦ even if the programmer leaves out all policy enforcing code, the Lifty repair engine is able to patch all leaks automatically within a reasonable time. Programming with a Read-Eval-Synth Loop   Hila Peleg, Roi Gabay, Shachar Itzhaky, Eran Yahav. In OOPSLA 2020 (ACM SIGPLAN conference on Systems, Programming, Languages, and Applications: Software for Humanity (OOPSLA track), 2020) Putting the Squeeze on Array Programs: Loop Verification via Inductive Rank Reduction   Oren Ish-Shalom, Shachar Itzhaky, Noam Rinetzky, Sharon Shoham. In VMCAI 2020 (International Conference on Verification, Model Checking, and Abstract Interpretation, January 2020) Harnessing Static Analysis to Help Learn Pseudo-Inverses of String Manipulating Procedures for Automatic Test Generation   Oren Ish-Shalom, Shachar Itzhaky, Roman Manevich, Noam Rinetzky. In VMCAI 2020 (International Conference on Verification, Model Checking, and Abstract Interpretation, January 2020) Property-Directed Inference of Universal Invariants or Proving Their Absence – extended version   Aleksander Karbyshev, Nikolaj Bjørner, Shachar Itzhaky, Noam Rinetzky, Sharon Shoham. In JACM 2017 (Journal of the ACM, 2017) Deriving Divide-and-Conquer Dynamic Programming Algorithms Using Solver-Aided Transformations Abstract  Shachar Itzhaky, Rohit Singh, Armando Solar-Lezama, Kuat Yessenov, Yongquan Lu, Charles Leiserson, Rezaul Chowdhury. In OOPSLA 2016 (ACM SIGPLAN conference on Systems, Programming, Languages, and Applications: Software for Humanity (OOPSLA track), Amsterdam, Netherlands, November 2016) We introduce a framework allowing domain experts to manipulate computational terms in the interest of deriving better, more efficient implementations. It employs deductive reasoning to generate provably correct efficient implementations from a very high-level specification of an algorithm, and inductive constraint-based synthesis to improve automation. Semantic information is encoded into program terms through the use of refinement types. In this paper, we develop the technique in the context of a system called Bellmania that uses solver-aided tactics to derive parallel divide-and-conquer implementations of dynamic programming algorithms that have better locality and are significantly more efficient than traditional loop-based implementations. Bellmania includes a high-level language for specifying dynamic programming algorithms and a calculus that facilitates gradual transformation of these specifications into efficient implementations. These transformations formalize the divide-and-conquer technique; a visualization interface helps users to interactively guide the process, while an SMT-based back-end verifies each step and takes care of low-level reasoning required for parallelism. We have used the system to generate provably correct implementations of several algorithms, including some important algorithms from computational biology, and show that the performance is comparable to that of the best manually optimized code. Abstract PDF Object Spreadsheets: a New Computational Model for End-user Development of Data-centric Web Applications Richard Matthew McCutchen, Shachar Itzhaky, Daniel Jackson In SPLASH 2016 Onward! (to appear November 2016) Spreadsheets offer many advantages as the computational and data-storage engine for applications that are authored by end users. Paradoxically, however, their main failing in this regard is their computational model. Despite being used in almost all cases to represent data that is essentially relational (with some hierarchical structuring), the spreadsheet model treats the two-dimensional grid as largely unstructured, with formulas linking cells in an ad hoc way. This paper reports on a quest to rethink the spreadsheet model. The model we propose supports not only conventional relational data, but also nested variable-size lists and object references. It includes a formula language suited to the data model and procedures to specify updates. The model has been implemented",
  "content_length": 24606,
  "method": "requests",
  "crawl_time": "2025-12-01 14:26:06"
}