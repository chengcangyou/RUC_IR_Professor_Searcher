{
  "name": "Neelakantan R. Krishnaswami",
  "homepage": "https://www.cl.cam.ac.uk/~nk480",
  "status": "success",
  "content": "Neelakantan R. Krishnaswami Neel Krishnaswami Work I am a professor of computer science at the Computer Laboratory, at the University of Cambridge. I am also a fellow of Trinity College. My research interests lie at the intersection of program verification; programming language design; and logic, semantics and type theory. Contact Postal: Neel Krishnaswami University of Cambridge Computer Laboratory William Gates Building 15 JJ Thomson Avenue Cambridge CB3 0FD, UK Office: FS15 Telephone: +44 122 376 3617 Email: <nk480@cl.cam.ac.uk> Blog: Semantic Domain Github: https://github.com/neel-krishnaswami ORCID id: https://orcid.org/0000-0003-2838-5865 Publications Draft Papers Students History Conference Papers and Journal Articles Explicit Refinement Types, Jad Ghalayini and Neel Krishnaswami. Accepted for publication at ICFP 2023. ‚Üí Abstract ‚Üí BibTeX We present Œª-ert, a type theory supporting refinement types with explicit proofs. Instead of solving refinement constraints with an SMT solver like DML and Liquid Haskell, our system requires and permits programmers to embed proofs of properties within the program text, letting us support a rich logic of properties including quantifiers and induction. We show that the type system is sound by showing that every refined program erases to a simply-typed program, and by means of a denotational semantics, we show that every erased program has all of the properties demanded by its refined type. All of our proofs are formalised in Lean 4. @article{ert, author = {Ghalayini, Jad and Krishnaswami, Neel}, title = {Explicit Refinement Types}, year = {2023}, issue_date = {September 2023}, publisher = {Association for Computing Machinery}, address = {New York, NY, USA}, volume = {8}, number = {ICFP}, journal = {Proceedings of the ACM on Programming Languages}, month = {sep}, numpages = {28}, keywords = {refinement types, first order logic, denotational semantics} } flap: A Deterministic Parser with Fused Lexing, Jeremy Yallop, Ningning Xie, and Krishnaswami. Accepted for publication at PLDI 2023. A long version with technical appendix is available on the ArXiV. ‚Üí Abstract ‚Üí BibTeX Lexers and parsers are typically defined separately and connected by a token stream. This separate definition is important for modularity, but harmful for performance. We show how to fuse separately-defined lexers and parsers, drasticaly improving performance without compromising modularity. We propose a deterministic variant of Greibach Normal Form that ensures de- terministic parsing with a single token of lookahead and makes fusion strikingly simple, and prove that normalizing context free expressions into the deterministic normal form is semantics-preserving. Our staged parser combinator library, flap, provides a standard interface, but generates specialized token-free code that runs two to six times faster than ocamlyacc on a range of benchmarks. @article{flap, author = {Jeremy Yallop and Ningning Xie and Neel Krishnaswami }, title = {flap: A Determiministic Parser with Fused Lexing}, journal = {{PACMPL}}, volume = {7}, number = {{PLDI}}, year = {2023}, note = {\\url{http://www.cl.cam.ac.uk/~nk480/flap.pdf}} } CN: Verifying Systems C Code with Separation-Logic Refinement Types, Christopher Pulte, Dhruv C. Makwana, Thomas Sewell, Kayvan Memarian, Peter Sewell, Neel Krishnaswami. Accepted for publication at POPL 2023. ‚Üí Abstract ‚Üí BibTeX Despite significant progress in the verification of hypervisors, operating systems, and compilers, and in verifi- cation tooling, there exists a wide gap between the approaches used in verification projects and conventional development of systems software. We see two main challenges in bringing these closer together: verification handling the complexity of code and semantics of conventional systems software, and verification usability. We describe an experiment in verification tool design aimed at addressing some aspects of both: we design and implement CN, a separation-logic refinement type system for C systems software, aimed at predictable proof automation, based on a realistic semantics of ISO C. CN reduces refinement typing to decidable propositional logic reasoning, uses first-class resources to support pointer aliasing and pointer arithmetic, features resource inference for iterated separating conjunction, and uses a novel syntactic restriction of ghost variables in specifications to guarantee their successful inference. We implement CN and formalise key aspects of the type system, including a soundness proof of type checking. To demonstrate the usability of CN we use it to verify a substantial component of Google‚Äôs pKVM hypervisor for Android. @article{cn, author = {Christopher Pulte and Dhruv C. Makwana and Thomas Sewell and Kayvan Memarian and Peter Sewell and Neel Krishnaswami }, title = {CN: Verifying Systems C Code with Separation-Logic Refinement Types}, journal = {{PACMPL}}, volume = {7}, number = {{POPL}}, year = {2023}, note = {\\url{http://www.cl.cam.ac.uk/~nk480/cn.pdf}} } Provably Correct, Asymptotically Efficient, Higher-Order Reverse-Mode Automatic Differentiation, Faustyna Krawiec, Simon Peyton-Jones, Neel Krishnaswami, Tom Ellis, Richard A. Eisenberg, and Andrew Fitzgibbon. Accepted for publication at POPL 2022. ‚Üí Abstract ‚Üí BibTeX In this paper, we give a simple and efficient implementation of reverse-mode automatic differentiation, which both extends easily to higher-order functions, and has run time and memory consumption linear in the run time of the original program. In addition to a formal description of the translation, we also describe an implementation of this algorithm, and prove its correctness by means of a logical relations argument. @article{higher-order-ad, author = {Faustyna Krawiec and Simon Peyton-Jones and Neel Krishnaswami and Tom Ellis and Richard A. Eisenberg and Andrew Fitzgibbon }, title = {Provably Correct, Asymptotically Efficient, Higher-Order Reverse-Mode Automatic Differentiation}, journal = {{PACMPL}}, volume = {6}, number = {{POPL}}, year = {2022}, note = {\\url{http://www.cl.cam.ac.uk/~nk480/higher-order-ad.pdf}} } Adjoint Reactive GUI Programming, Christial Uldal Graulund, Dimitrij Szamozvancev, and Neel Krishnaswami. Accepted for publication at FOSSACS 2020.. Link to ArXiV version ‚Üí Abstract ‚Üí BibTeX Most interaction with a computer is done via a graphical user interface. Traditionally, these are implemented in an imperative fashion using shared mutable state and callbacks. This is efficient, but is also difficult to reason about and error prone. Functional Reactive Programming (FRP) provides an elegant alternative which allows GUIs to be designed in a declarative fashion. However, most FRP languages are synchronous and continually check for new data. This means that an FRP-style GUI will \"wake up\" on each program cycle. This is problematic for applications like text editors and browsers, where often nothing happens for extended periods of time, and we want the implementation to sleep until new data arrives. In this paper, we present an asynchronous FRP language for designing GUIs called Œªùñ∂ùóÇùñΩùóÄùñæùóç. Our language provides a novel semantics for widgets, the building block of GUIs, which offers both a natural Curry--Howard logical interpretation and an efficient implementation strategy. @InProceedings{10.1007/978-3-030-71995-1_15, author=\"Graulund, Christian Uldal and Szamozvancev, Dmitrij and Krishnaswami, Neel\", editor=\"Kiefer, Stefan and Tasson, Christine\", title=\"Adjoint Reactive GUI Programming\", booktitle=\"Foundations of Software Science and Computation Structures\", year=\"2021\", publisher=\"Springer International Publishing\", address=\"Cham\", pages=\"289--309\", isbn=\"978-3-030-71995-1\" } Bidirectional Typechecking, Jana Dunfield and Neel Krishnaswami. To appear in ACM Computing Surveys. Link to ArXiV version ‚Üí Abstract ‚Üí BibTeX Bidirectional typing combines two modes of typing: type checking, which checks that a program satisfies a known type, and type synthesis, which determines a type from the program. Using checking enables bidirectional typing to break the decidability barrier of Damas-Milner approaches; using synthesis enables bidirectional typing to avoid the large annotation burden of explicitly typed languages. In addition, bidirectional typing improves error locality. We highlight the design principles that underlie bidirectional type systems, survey the development of bidirectional typing from the prehistoric period before Pierce and Turner's local type inference to the present day, and provide guidance for future investigations. @Unpublished{Dunfield21:bidir-survey, author = {Jana Dunfield and Neel Krishnaswami}, title = {Bidirectional Typing}, year = {2021}, note = {\\url{arXiv:1908.05839 [cs.PL]}} } Transfinite Step-Indexing for Termination, Simon Spies, Neel Krishnaswami and Derek Dreyer. Accepted for publication at POPL 2021. (See also the MPI website, and also the PDF with full proofs.) ‚Üí Abstract ‚Üí BibTeX Step-indexed logical relations are an extremely useful technique for building operational-semantics-based models and program logics for realistic, richly-typed programming languages. They have proven to be indispensable for modeling features like higher-order state, which many languages support but which were difficult to accommodate using traditional denotational models. However, the conventional wisdom is that, because they only support reasoning about finite traces of computation, (unary) step-indexed models are only good for proving safety properties like ‚Äúwell-typed programs don‚Äôt go wrong‚Äù. There has consequently been very little work on using step-indexing to establish liveness properties, in particular termination. In this paper, we show that step-indexing can in fact be used to prove termination of well-typed programs -- even in the presence of dynamically-allocated, shared, mutable, higher-order state‚Äîso long as one‚Äôs type system enforces disciplined use of such state. Specifically, we consi",
  "content_length": 60832,
  "method": "requests",
  "crawl_time": "2025-12-01 14:04:16"
}