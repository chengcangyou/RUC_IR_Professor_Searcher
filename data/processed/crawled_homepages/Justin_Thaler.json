{
  "name": "Justin Thaler",
  "homepage": "http://people.cs.georgetown.edu/jthaler",
  "status": "success",
  "content": "Justin Thaler Justin Thaler Associate Professor Georgetown University Department of Computer Science St. Mary's Hall, Room 354 3700 Reservoir Road NW Washington, DC 20057 e-mail: justin [dot] thaler [at] georgetown [dot] edu About Me Teaching Publications Service Open Source Software CV About Me I am broadly interested in algorithms and computational complexity, primarily focusing on the following three research goals. Understanding the power of low-degree polynomials to approximate Boolean functions. Answering these questions has a variety of applications, especially to quantum computing, learning theory, and computational complexity theory. Designing protocols for proving the correctness of computations (possibly in zero-knowlege), in which the prover and verifier are highly efficient both in theory and in practice. Developing efficient streaming and sketching algorithms for basic tasks that are often performed on large data sets. I am an Associate Professor at Georgetown University and a Research Partner at a16z crypto research. Prior to joining Georgetown, I spent two years as a Research Scientist at Yahoo Labs in New York. Before that, I was a Research Fellow at the Simons Institute for the Theory of Computing at UC Berkeley. I received my Ph.D. from the Theory of Computation Group at Harvard University, where I was fortunate to be advised by Michael Mitzenmacher, and I graduated from Yale University in 2009 with a B.S. in Computer Science and a second major in Mathematics. I am currently at a16z crypto research and on leave from Georgetown. Teaching COSC 544 -- Probabilistic Proof Systems (Fall 2020, Fall 2017) COSC 547 -- Analytic Techniques in Computer Science (Fall 2022) COSC 548 -- Streaming Algorithms (Fall 2018, Fall 2016) ANLY 550 -- Structures and Algorithms for Analytics (Spring 2019, Spring 2018, Spring 2017) ANLY 558 -- Advanced Algorithms for Analytics (Spring 2021) Current and Former Students and Postdocs Shuchen Zhu (PhD Student) Sidhant Saraogi (PHD Student, co-advised with Sasha Golovnev) Alex Block (postdoc) Prantar Ghosh (postdoc) Nikhil Mande (former postdoc, now a postdoc at CWI) Research Papers 2023 The Sum-Check Protocol over Fields of Small Characteristic Justin Thaler Manuscript Links: [pdf] Abstract: The sum-check protocol of Lund, Fortnow, Karloff, and Nisan underlies SNARKs with the fastest known prover. In many of its applications, the prover can be implemented with a number of field operations that is linear in the number, n, of terms being summed. We describe an optimized prover implementation when the protocol is applied over an extension field of a much smaller base field. The rough idea is to keep most of the proverâ€™s multiplications over the base field (at the cost of performing more total field multiplications). When the sum-check protocol is applied to a product of polynomials that all output values in the base field, our algorithm reduces the number of extension field operations by multiple orders of magnitude. In other settings, our improvements are more modest but nonetheless meaningful. In SNARK design, the sum-check protocol is often combined with a polynomial commitment scheme, which are growing faster, especially when the values being committed are small. These improved commitment schemes may render the sum-check prover the overall bottleneck, which our results help to mitigate. BabySpartan: Lasso-based SNARK for non-uniform computation Srinath Setty, and Justin Thaler Manuscript Links: [e-print] Abstract: Lasso (Setty, Thaler, Wahby, ePrint 2023/1216) is a recent lookup argument that ensures that the prover cryptographically commits to only \"small\" values. This note describes BabySpartan, a SNARK for a large class of constraint systems that achieves the same property. The SNARK is a simple combination of SuperSpartan and Lasso. The specific class of constraint systems supported is a generalization of so-called Plonkish constraint systems (and a special case of customizable constraint systems (CCS)). Whereas a recent work called Jolt (Arun, Setty, and Thaler, ePrint 2023/1217) can be viewed as an application of Lasso to uniform computation, BabySpartan can be viewed as applying Lasso to non-uniform computation. Jolt: SNARKs for Virtual Machines via Lookups Arasu Arun Srinath Setty, and Justin Thaler Manuscript Links: [e-print] Abstract: Succinct Non-interactive Arguments of Knowledge (SNARKs) allow an untrusted prover to establish that it correctly ran some \"witness-checking procedure\" on a witness. A zkVM (short for zero-knowledge Virtual Machine) is a SNARK that allows the witness-checking procedure to be specified as a computer program written in the assembly language of a specific instruction set architecture (ISA). A front-end converts computer programs into a lower-level representation such as an arithmetic circuit or generalization thereof. A SNARK for circuit-satisfiability can then be applied to the resulting circuit. We describe a new front-end technique called Jolt that applies to a variety of ISAs. Jolt arguably realizes a vision called the \"lookup singularity\", which seeks to produce circuits that only perform lookups into pre-determined lookup tables. The circuits output by Jolt primarily perform lookups into a gigantic lookup table, of size more than $2^{128}$, that depends only on the ISA. The validity of the lookups are proved via a new lookup argument called Lasso described in a companion work (Setty, Thaler, and Wahby, e-print 2023). Although size-$2^{128}$ tables are vastly too large to materialize in full, the tables arising in Jolt are structured, avoiding costs that grow linearly with the table size. We describe performance and auditability benefits of Jolt compared to prior zkVMs, focusing on the popular RISC-V ISA as a concrete example. The dominant cost for the Jolt prover applied to this ISA (on 64-bit data types) is cryptographically committing to about six 256-bit field elements per step of the RISC-V CPU. This compares favorably to prior zkVM provers, even those focused on far simpler VMs. Unlocking the lookup singularity with Lasso Srinath Setty, Justin Thaler, and Riad Wahby Manuscript Links: [e-print] Abstract: This paper introduces Lasso, a new family of lookup arguments, which allow an untrusted prover to commit to a vector $a \\in \\mathbb{F}^m$ and prove that all entries of $a$ reside in some predetermined table $t \\in \\mathbb{F}^n$. Lasso's performance characteristics unlock the so-called ``lookup singularity''. Lasso works with any multilinear polynomial commitment scheme, and provides the following efficiency properties. For $m$ lookups into a table of size $n$, Lasso's prover commits to just $m+n$ field elements. Moreover, the committed field elements are \\emph{small}, meaning that, no matter how big the field $\\mathbb{F}$ is, they are all in the set $\\{0, \\dots, m\\}$. When using a multiexponentiation-based commitment scheme, this results in the prover's costs dominated by only $O(m+n)$ group \\emph{operations} (e.g., elliptic curve point additions), plus the cost to prove an evaluation of a multilinear polynomial whose evaluations over the Boolean hypercube are the table entries. This represents a significant improvement in prover costs over prior lookup arguments (e.g., plookup, Halo2's lookups, lookup arguments based on logarithmic derivatives). Unlike all prior lookup arguments, if the table $t$ is structured (in a precise sense that we define), then no party needs to commit to $t$, enabling the use of much larger tables than prior works (e.g., of size $2^{128}$ or larger). Moreover, Lasso's prover only ``pays'' in runtime for table entries that are accessed by the lookup operations. This applies to tables commonly used to implement range checks, bitwise operations, big-number arithmetic, and even transitions of a full-fledged CPU such as RISC-V. Specifically, for any integer parameter $c>1$, Lasso's prover's dominant cost is committing to $3 \\cdot c \\cdot m + c \\cdot n^{1/c}$ field elements. Furthermore, all these field elements are ``small'', meaning they are in the set $\\{0, \\dots, \\max\\{m, n^{1/c}, q\\}-1\\}$, where $q$ is the maximum value in $a$. Lasso's starting point is Spark, a time-optimal polynomial commitment scheme for sparse polynomials in Spartan (CRYPTO 2020). We first provide a stronger security analysis for Spark. Spartan's security analysis assumed that certain metadata associated with a sparse polynomial is committed by an honest party (this is acceptable for its purpose in Spartan, but not for Lasso). We prove that Spark remains secure even when that metadata is committed by a malicious party. This provides the first ``standard'' commitment scheme for sparse multilinear polynomials with optimal prover costs. We then generalize Spark to directly support a lookup argument for both structured and unstructured tables, with the efficiency characteristics noted above. Customizable constraint systems for succinct arguments Srinath Setty, Justin Thaler, and Riad Wahby Manuscript Links: [e-print] Abstract: This paper introduces customizable constraint system (CCS), a generalization of R1CS that can simultaneously capture R1CS, Plonkish, and AIR without overheads. Unlike existing descriptions of Plonkish and AIR, CCS is not tied to any particular proof system. Furthermore, we observe that the linear-time polynomial IOP for R1CS in Spartan (CRYPTO 20) extends easily to CCS, and when combined with a polynomial commitment scheme, it yields a family of SNARKs for CCS, which we refer to as SuperSpartan. SuperSpartan supports high-degree constraints without its prover incurring cryptographic costs that scale with the degree of constraints (only field operations scale with the constraint degree). Moreover, as in Spartan, it does not employ superlinear-time and hard-to-distribute operations such as FFTs. Similar properties were achieved for Plonkish by HyperPlonk (EUROCRYPT 23) via a different route. However, it is unc",
  "content_length": 102992,
  "method": "requests",
  "crawl_time": "2025-12-01 13:38:30"
}