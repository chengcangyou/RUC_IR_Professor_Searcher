{
  "name": "Bradley J. Lucier",
  "homepage": "https://www.math.purdue.edu/~lucier",
  "status": "success",
  "content": "Bradley J. Lucier Bradley J. Lucier Professor Emeritus of Mathematics and Computer Science Purdue University Math G138 150 North University Street W. Lafayette, IN 47907-2067 lucier@math.purdue.edu orcid.org/0000-0003-3808-939X A professor can do as he pleases, but a professor emeritus can do as he damn well pleases. Nicolaas Bloembergen Kipling was a Conservative, a thing that does not exist nowadays. Those who now call themselves Conservatives are either Liberals, Fascists or the accomplices of Fascists. George Orwell, September 1941 You're an evil man. Linus Torvalds Thank you. Publications A complete list of my papers can be found on my \"bio\" page . You can download various papers by me and my previous students on image processing and wavelets and numerical methods for partial differential equations and related topics. A publication that doesn't quite fit in with those two lists is How I First Heard About Calculus which appears in the Journal of Humanistic Mathematics. I heard about calculus from a daily science cartoon strip, and I say in the article that I was interested enough in science to search out that strip in my local paper, but that isn't quite right---I was interested enough in cartoons to search for all of them in the daily newspaper, and because a group in Australia syndicated a daily science cartoon that my local paper decided to reproduce, I happened to learn about science. Not only is that version more correct, but it's more interesting. The paper The Nature of Numbers: Real Computing also appeared in the Journal of Humanistic Mathematics. The abstract is: While studying the computable real numbers as a professional mathematician, I came to see the computable reals, and not the real numbers as usually presented in undergraduate real analysis classes, as the natural culmination of my evolving understanding of numbers as a schoolchild. This paper attempts to trace and explain that evolution. The first part recounts the nature of numbers as they were presented to us grade-school children. In particular, the introduction of square roots induced a step change in my understanding of numbers. Another incident gave me insight into the brilliance of Alan Turing in his paper introducing both the computable real numbers and his famous ``Turing machine''. The final part of this paper describes the computable real numbers in enough detail to supplement the usual undergraduate real analysis class. An appendix presents programs that implement the examples in the text. The page of code at the end is written in the Scheme programming language. Errata (some are thanks to Bill Richter): Top of page 328, change \"to compute each new digits\" to \"to compute each new digit\". Page 338, end of the fifth paragraph, change \"$|A_{T(K)}-A|<\\frac 1 K$\" to \"$|A_N-A|<\\frac 1 K$ for $N\\geq T(K)$\". Conjecture on the norm of \"Discrete White Noise\" in the dual of BV (\"Conjecture\" is too grand a word, but I can't think of a better one.) In Pointwise Besov Space Smoothing of Images we consider the following problem: Let an image $\\epsilon$ be defined on $I=[0,1]^2$, the unit square, divided into $N\\times N$ subsquares $I_i$ indexed by the multi-index $i=(i_1,i_2)$, $0\\leq i_1,i_2<N$. The value of the image $\\epsilon$ on $I_i$ is given by $\\epsilon_i$, where the $\\epsilon_i$ are i.i.d. $N(0,1)$ random variables. For various reasons it's interesting to estimate the expected value of the norm of $\\epsilon$ in the dual space of $\\text{BV}(I)$, the space of functions of bounded variation on $I$. Specifically, we want to estimate $$E\\left(|\\epsilon|_{\\text{BV(I)}^*}\\right)=E\\left(\\sup_{\\|f\\|_{\\text{BV}(I)}\\leq 1}\\left|\\int_I f\\epsilon\\right|\\right).\\tag{1}$$ We note in Section 8 of the previously mentioned paper that because of the strict norm inclusions $B^1_1(L_1(I))\\subset\\text{BV}(I)\\subset B^1_\\infty(L_1(I))$ between $\\text{BV}(I)$ and the Besov spaces $B^1_1(L_1(I))$ and $ B^1_\\infty(L_1(I))$, we can exploit wavelet atomic decompositions of the Besov spaces to show that there exist two constants $C_1$ and $C_2$ such that $$ C_1\\frac{|\\log N|^{1/2}}N\\leq E\\left(|\\epsilon|_{\\text{BV(I)}^*}\\right)\\leq C_2\\frac{|\\log N|^{3/2}}N. $$ I conjecture the tighter bounds $$ C_1\\frac{\\log N}N\\leq E\\left(|\\epsilon|_{\\text{BV(I)}^*}\\right)\\leq C_2\\frac{\\log N}N. $$ Update: We updated the supremeum in Equation (1) to replace $|f|_{\\text{BV}(I)}$ by $\\|f\\|_{\\text{BV}(I)}=|f|_{\\text{BV}(I)}+\\|f\\|_{L^1(I)}$. Alternately, one could keep $|f|_{\\text{BV}(I)}$ and require $\\int_I f=0$. Courses CS/MA 615: Numerical Methods for Partial Differential Equations, legacy version. And the versions from 2016, 2014, 2012, 2010, 2008, 2003, and 2000. Math 692B: Wavelets and Image Processing, Fall 2000 Suggested Projects Related Papers Test Images Test Images High quality, grey-scale, test images for purposes of testing algorithms on natural images. Some results from my compression program are given. The original Kodak Photo CD Photo Sampler color images from which the greyscale images above were derived, and the copyright terms under which the Kodak Photo CD Photo Sampler images were released. If anyone can tell me a standard way to convert these to YUV, YCrCb, or RGB, I'd be interested. Later note: it seems that various versions of Photoshop have good color conversion between Kodak Photo CD format and RGB, so that is what I used for the color versions. I'm still not happy with Photoshop's conversion to grey-scale. You can find a lot of useful information about working with Photo CD images at Ted's Unofficial Kodak Photo CD Homepage. Non-blogs James R. Lee claims that he's writing a \"non-blog\" about some mathematics of theoretical computer science. It's great stuff as mathematics, and I presume as computer science, too. (James was an undergraduate at Purdue.) Software Software for the numerical approximation of solutions of elliptic and parabolic partial differential equations (from CS 615). Schelog, an embedding of Prolog into Scheme that was written by Dorai Sitaram, adapted for Gambit-C. Meroon, an object-oriented extension to Scheme, written by Christian Queinnec and modified to run well on Gambit-C. Programming with arrays: In my work on image processing I've thought a lot about how to program using arrays. Eventually I developed some proposals for what the basis of array library should be; this culminated in a Scheme Request For Implementation, SRFI 231: Intervals and Generalized Arrays. In terms of the basic operations of reordering, decomposing, and recomposing arrays I believe this library is more complete and regular than, e.g., the NumPy library of Python. The sample implementation is written in Gambit Scheme. Beating the Averages by Paul Graham tells how to beat your competitors using Lisp. He also wrote Revenge of the Nerds. Design Patterns in Dynamic Programming by Peter Norvig explains why many of the classical design patterns used in C++ or Java are trivial or not needed in dynamic languages like Common Lisp, Scheme, and Dylan, and presents new, more powerful, design patterns for dynamic languages. Later addition: Richard P. Gabriel, a strong proponent of design patterns in computer programming, claims that the Gang of Four \"Design Patterns\" book for C++ and Java programmers helps \"losers lose less\", and that design patterns (lower case) are powerful techniques for organizing computer programs, even in dynamic programming languages. A Common Lisp tutorial. Lawrence Lessig talks about how extensions to copyright terms over the last 40 years form theft from the public; how software patents are holding back innovation; how small losses to copyright holders are leading to federal proposals of legal vigilantism, where corporations are given free rein to hack your computer; and what you can do about it. Hackers, Slackers, and Shackles: The Future of Free Software Game Development is an interesting essay about several things: the history of the computer gaming industry, the importance of computer games in motivating learning about computers, and how open-sourcing computer games would increase innovation and progress. There are blog aggregators for Lisp and Scheme. Why Lisp? Structure and Interpretation of Computer Programs, by Harold Abelson and Gerald Jay Sussman with Julie Sussman, is the best book on programming ever written, it happens to use the programming language Scheme, and it's available online. The book is divided into chapters that discuss various high-level strategies to organize programs: Building Abstractions with Procedures Building Abstractions with Data Modularity, Objects, and State Metalinguistic Abstraction Computing with Register MachinesA more recent book, Software Design for Flexibility: How to Avoid Programming Yourself into a Corner by Chris Hanson and Gerald Jay Sussman, seems to build on this theme, but I haven't read it yet. SICP is somewhat mathematical and moves at a pretty fast clip; if you want a slower introduction to programming using Scheme, I recommend The Schematics of Computation, which contains all the big ideas of SICP, but uses a broader range of examples---I call it \"SICP for mortals\". Unfortunately, it's not available online but I think it's worth buying. In a hurry? Try Teach Yourself Scheme in Fixnum Days by Dorai Sitaram. Another text available online is How to Design Programs, which is closely integrated with Racket (formerly PLT Scheme). Of the few French textbooks that I know, I like Programmer avec Scheme: De la pratique à la théorie, by Jacques Chazarain. And, if you're looking for programming exercises that are not trivial but not too involved, try the blog Programming Praxis, written by Phil Bewig. Learn visually? John Clements has collected a list of Scheme video lectures and talks. Alex Harsányi has a blog of small, interesting projects in Racket. My favorite Scheme implementation is Gambit Scheme, written mainly by Marc Feeley. Use functional programming to deliver single-source, free-standing gr",
  "content_length": 13149,
  "method": "requests",
  "crawl_time": "2025-12-01 13:05:59"
}