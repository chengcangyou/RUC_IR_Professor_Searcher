{
  "name": "Krzysztof Stencel",
  "homepage": "http://uw.academia.edu/KrzysztofStencel",
  "status": "success",
  "content": "Krzysztof Stencel - University of Warsaw Skip to main content Academia.edu no longer supports Internet Explorer.To browse Academia.edu and the wider internet faster and more securely, please take a few seconds to upgrade your browser. Log InSign UpLog InSign Upmore AboutPressPapersTermsPrivacyCopyright We're Hiring! Help Centerless Krzysztof StencelUniversity of Warsaw, Faculty of Mathematics, Informatics and Mechanics, Faculty MemberaddFollowdoneFollowingFollowers71Following21Co-authors21Public ViewsRelated Authors Marta Jadwiga BurzańskaUniwersytet Mikołaja Kopernika w Toruniu Vincenzino Lio Claudio Panetta Alejandro C Hamid PiraheshIBM Research Yannis ManolopoulosAristotle University of Thessaloniki Alfredo CuzzocreaUniversity of Calabria Aleksandra Boniewicz Ernest Teniente guy MartinInterests UploadsPapers by Krzysztof StencelPushing Predicates into Recursive SQL Common Table Expressionsby Marta Jadwiga Burzańska and Krzysztof StencelLecture Notes in Computer Science, 2009A recursive SQL-1999 query consists of a recursive CTE (Common ) and a query which uses it. If su... more A recursive SQL-1999 query consists of a recursive CTE (Common ) and a query which uses it. If such a recursive query is used in a context of a selection predicate, this predicate can possibly be pushed into the CTE thus limiting the breadth and/or depth of the recursive search. This can happen e.g. after the definition of a view containing recursive query has been expanded in place. In this paper we propose a method of pushing predicates and other query operators into a CTE. This allows executing the query with smaller temporary data structures, since query operators external w.r.t. the CTE can be computed on the fly together with the CTE. Our method is inspired on the deforestation (a.k.a. program fusion) successfully applied in functional programming languages.Download Querying Workflows over Distributed Systemsby Kazimierz Subieta and Krzysztof Stencel Universal Query Language for Unified State ModelUnified State Model (USM) is a single data model that allows conveying objects of major programmi... more Unified State Model (USM) is a single data model that allows conveying objects of major programming languages and databases. USM exploits and emphasizes common properties of their data models. USM is equipped with mappings from these data models onto it. With USM at hand, we have faced the next natural research question whether numerous query languages for the data subsumed by USM can be clearly mapped onto a common language. We have designed and proposed such a language called the Unified Query Language (UQL). UQL is intended to be a minimalistic and elegant query language that allows expressing queries of languages of data models covered by USM. In this paper we define UQL and its concise set of operators. Next we conduct a mild introduction into UQL features by showing examples of SQL and ODMG OQL queries and their mapping onto UQL. We conclude by presenting the mapping of the theoretical foundations of these two major query languages onto UQL. They are the multiset relational algebra and the object query algebra. This is an important step towards the establishment of a fully-fledged common query language for USM and its subsumed data models.Download Granular Indices for HQL Analytic Queries On Visual Assessment of Software Quality Exploiting Order Dependencies on Primary Keys for Optimization Visitor Pattern Revisited for Recognition On quick comprehension and assessment of softwareBy an architecture of a software system we mean the fundamental organization of the system embodi... more By an architecture of a software system we mean the fundamental organization of the system embodied in its components, their relationships to one another and to the system's environment. It also encompasses principles governing the system's design and evolution. Architectures of complex systems are obviously complex as well. The goal of our research is to harness this complexity. In this paper we focus on providing software architects with ability to quickly comprehend the complexity and assess the quality of software. The essential tools we use are: (1) a graph-based repository for collecting information on software artefacts, accompanied by (2) tools to perform software intelligence tasks, like analyzing dependencies among those artefacts, calculating their importance, and quality. On top of those tools we implement visualization methods that render the relative importance using size and the quality using colours. By means of such methods a software architect can at glance comprehend and assess the software, He/she can (1) find the starting points to dig into a complex system; (2) judge the cohesion and coupling of system components; and (3) assess the overall quality. We demonstrate this method using selected open-source projects of various sizes and qualities.Download On Redundant Data for Faster Recursive Querying Via ORM Systemsby Krzysztof Stencel and Aleksandra BoniewiczPersistent data of most business applications contain recursive data structures, i.e. hierarchies... more Persistent data of most business applications contain recursive data structures, i.e. hierarchies and networks. Processing such data stored in relational databases is not straightforward, since the relational algebra and calculus do not provide adequate facilities. Therefore, it is not surprising that initial SQL standards do not contain recursion as well. Although it was introduced by SQL:1999, even now it is implemented in few selected database management systems. In particular, one of the most popular DBMSs (MySQL) does support recursive queries yet. Numerous classes of queries can be accelerated using redundant data structures. Recursive queries form such a class. In this paper we consider four materialization solutions that speed up recursive queries. Three of them belong to the state-of-the-art, while the fourth one is the contribution of this paper. The latter method assures that the required redundant storage is linearithmic. The other methods do not guarantee such a limitation. We also present thorough experimental evaluation of all these solutions using data of various sizes up to million records. Since all these methods require writing complex code if applied directly, we have prototyped an integration of them into Hibernate object-relational mapping system. This way all the peculiarities are hidden from application developers. Architects can simply choose the appropriate materialization method and record their decisions in configuration files. All necessary routines and storage objects are then generated automatically by the ORM layer.Download Enhanced segment trees in object-relational mappingTree-shaped data often occur in business applications, e.g. a corporate hierarchy or a categoriza... more Tree-shaped data often occur in business applications, e.g. a corporate hierarchy or a categorization of products. A natural class of analytic queries posed to such data consists of aggregate queries over subtrees. Evaluation of such queries in large data sets requires significant amount of time. In this paper we focus on dedicated data structures that materialize partial results of such queries in a form of well-known segment trees. In a multiprogramming environment such data structures require careful implementation. A naïve design is going to suffer from synchronization problems. The root of such a structure will be updated by each transaction that changes anything down its subtree. We propose ring updates that allow using the presented data structure with multiple execution threads. Our implementation is designed to work with object-relational mapping systems. If an application uses stored hierarchical data, its designer can add annotations to augment mapped database objects with materialization of partial aggregations over subtrees. Mapping generators create all necessary storage objects and triggers. We describe our proof-of-concept prototype implementation of this feature in Hibernate. We also present an experimental evaluation of this prototype's performance. The results confirm that the proposed materializations notably boost the evaluation of analytical queries over hierarchies.Download Systemy zarządzania bazami danychby Krzysztof Stencel and L. Banachowski One graph to rule them all software measurement and management On Materializing Paths for Faster Recursive Queryingby Krzysztof Stencel and Aleksandra Boniewicz Relaxing Queries to Detect Variants of Design PatternsDesign patterns codify general solutions to frequently encountered design problems. They also fac... more Design patterns codify general solutions to frequently encountered design problems. They also facilitate writing robust and readable code. Their usage happens to be particularly profitable if the documentation of the resulting system is lost, inaccurate or out of date. In reverse engineering, detection of instances of design patterns is extremely helpful as it aids grasping high level design ideas. However, the actual instances of design patterns can diverge from their canonical textbook templates. Useful pattern detection tools should thus be able to identify not only orthodox implementations but also their disparate variants. In this paper, we present a method to generate queries to detect canonical instances of design patters. We formulate these queries so that they are language-agnostic. They precisely reflect the intents of the canonical implementations of design patterns. However, they abstract from any peculiarities of programming languages. Next, we show a systematic technique to relax these queries so that they also cover variant implementations of patterns. We discuss our proof-of-concept implementation of this approach in our prototype tool D-CUBED. Finally, we report the results of an experimental comparison of D-CUBED and stateof-the-art detectors.Download Know Thy Sourc",
  "content_length": 11448,
  "method": "requests",
  "crawl_time": "2025-12-01 13:44:41"
}