{
  "name": "Marie-Christine Jakobs",
  "homepage": "https://www.sosy-lab.org/people/jakobs",
  "status": "success",
  "content": "Prof. Dr. Marie-Christine Jakobs, LMU Munich Prof. Dr. Marie-Christine Jakobs Professor, Reliable Software Software and Computational Systems Lab Department of Computer Science Ludwig-Maximilians-Universität München (LMU Munich) Oettingenstraße 67 80538 Munich (Germany) OfficeRoom 058, Oettingenstr. 67 E-Maillastname@sosy.ifi.lmu.de (You need to replace lastname.) ORCID 0000-0002-5890-4673 GPG-Key Please send me encrypted mails! My GPG key: Public Key Fingerprint: 78ED 2ABF EBA8 80FD 93DD B385 6C09 F182 7936 0D27 Short Biography In 2012, Marie-Christine Jakobs finished her studies in computer science at Paderborn University. She received her doctor's degree in 2017 from Paderborn University. From 2017 to 2019 she worked as postdoctoral researcher at LMU Munich. From 2019-2023 Marie-Christine Jakobs was an assistant professor at TU Darmstadt. Since 2023 she has been a professor for at Ludwig-Maximilians-Universität München. Open Positions We are currently hiring a research assistant, either on the level of a PhD student or a postdoctoral researcher for our DFG project ReVeriX. As a researcher in this project, you will work on innovative research questions with respect to efficient and flexible reverification of modified programs to safeguard modifed programs against property violations. For further details consider the job posting below. Research assistant (w/m/d) for reverification of modified programs Research Marie-Christine Jakobs main research is in the area of formal methods for verification of software. She is particularly interested in automatic software verification with a focus on static analysis, model checking, and testing. She is interested in theoretical foundations as well as tool development. Since 2012 she has been contributing to the software analysis tool CPAchecker. Her current research interests include incremental verification, verifier combinations, test-case generation, functional equivalence checking, and the validation of verification results. Current Research Interests Incremental verification To increase the efficiency of reverifying a program after it has been changed, we want to utilize knowledge gained while verifying previous versions of the program. On the one hand, we aim to speed up reverification by reusing information discovered during the verification of an earlier version of the program. We are in particular interested to reuse information from different verifiers. On the other hand, we develop techniques that focus reverification on paths affected by the modification. Verifier combinations Verifiers have different strength and weaknesses. Therefore, we aim to combine different verifiers to get better verifiers. Test-case generation We use verification techniques to automatically generate test cases. More concretely, our approaches check the reachability of all test goals and output test cases for all goals that are proved reachable. Thereby, we focus on combinations of different verification approaches. Functional equivalence checking In this area, we develop methods to check whether original and modified program are functional equivalent. Our main focus is on techniques to encode functional equivalence into verification tasks that can be efficiently solved. Validation of verification results In this area, we work on formats that allow verifiers to provide evidence for their results and on approaches to independently check a verifier's results based on the provided evidence. Publications All my publications are available at DBLP and Google Scholar. Funded Projects (Current and Past) ConVeY - Continuous Verification of CYber-Physical Systems (DFG Research Training Group) ReVeriX: Efficiently Reverifying Modified Programs Despite of Switching the Verification Approach (DFG Project) Software Factory 4.0 (Part Project L, LOEWE project, HMWK, 2019-2022) Currently supervised PhD students Max Barth Márk István Somorjai Software Projects CPAchecker Framework for Equivalence Checking of Parallelized Code (FECheck) Teaching Thesis Topics and Projects Typically, we offer thesis topics in the area of our current research. Below we list currently available topics. Further topics can be discussed on request. All topics offered by our chair are available on our teaching page. Available topics A Range To Condition Converter [1, 2, 3] Ranged program analysis [1] and Conditional Model Checking [2] are two different techniques to restrict an analysis to examine a subset of a program's behavior. In ranged program analysis, all paths are ordered and a subset of program paths is described by a range. A range is characterized by a lower and upper path that are typically described by a test input and describes all paths that are in order between lower and upper bound. In conditional model checking, the subset of paths is described by a an automaton like format, the condition, which accepts all program paths except for the paths in the subset. To let ranged program analysis and conditional model checking cooperate, we need to be able to transform between the two formats that describe subpaths.This thesis should develop a transformation from ranges to conditions. The goal of the this is develop a transformation, formally show that it is sound, i.e., the transformed condition describes the same paths as the original range. If this does not work, it should at least contain all paths of the original range. In addition, the transformation should be realized in the software analysis tool CPAchecker [3] and it should be evaluated as part of a combination of ranged program analysis and conditional model checking. Currently assigned topics Value Analysis with Initial Precision from YML Correctness Witness [1, 2, 3, 4] Value analysis [1] is one verification technique in the software analysis framework CPAchecker [2], which tracks the concrete values of certain variables that are determined by its precision. So far, value analysis may create an empty initial precision or an initial precision from an existing value or predicate precision, which in both cases is the result of a previous analysis run. This restricts the reuse of information in the value analysis. The goal of this thesis is to extend the ability of CPAchecker's value analysis to reuse information from previous analysis runs by using information provided in YML correctness witnesses [3]. The idea is to derive from the invariants in the witness the variables that should be tracked and add them to the precision. In addition to considering variables directly occurring in the witness' invariant, further variables might be derived similar to [4]. An experimental evaluation should evaluate the value of generating initial precisions from witnesses. The evaluation should at least compare initial precision from witnesses generated by the value analysis with initial precision from value precision in context of the reverification of changed programs and optionally of the same program. The evaluation may be extended by a comparison with an initial empty precision as well as a precision from predicate analysis, an initial precision from witnesses generated from other analyses like CPAchecker's predicate analysis, k-induction, or even generated by another tool. Similar to [4], the evaluation may further evaluate the approach in context of cooperative verification. Parallel Test-Case Generation via Test-Goal Splitting [1, 2, 3, 4] Test-case generation based on reachability analyses like CoVeriTest [1] check the reachability of each test goal, e.g., each branch of a program, and generate a test case whenever the check succeeds. The goal of this thesis is to develop an approach to parallelize such test-case generation approaches by splitting the set of test goals into disjoint subsets and then running multiple instances of the test-case generation in parallel, each instance focusing on one particular subset of the test goals. The main conceptual part of the thesis is the development of one or more split strategies. Ideally the strategies should consider dependencies, e.g., dominator information or control-dependencies [2], or other structural relations between test goals. In addition, a baseline strategy, e.g., random splitting, should be provided. Since a test case may cover more than the test goal it is generated for, the parallelization approach should also support to exchange information about covered test goals to avoid generating test cases for already covered test goals. Ideally, the developed approach would support load balancing, i.e., the redistribution of uncovered test goals from one instance of the test-case generation approach to another one. The developed approach must be integrated into CPAchecker's [3] test-case generation and experimentally evaluated on the benchmarks of the international testing competition (Test-Comp) [4]. The evaluation must compare the approach to sequential test-case generation and compare the different strategies. Detecting Collaterally Covered Goals with CPAchecker's Value Analysis [1, 2, 3, 4] Software testing is a standard means in quality assurance supported e.g., by automatic tools for test input generation. Several of these automatic tools generate test suites aiming at maximizing the value wrt. a coverage criterion like branch coverage. One particular class of tools are test-case generators based on model checkers like CPAchecker [1,2,3]. These tools derive test goals from the coverage criterion (e.g., the set of branches in a program) and show the reachability of each goal to derive tests. Often, one generated test can reach more than the test goal it was created for. While it is easy to detect other test goals that were visited before reaching the test goal of interest and model-checking based test-case generators often would have covered those test goals with a previous test anyways, other test goals visited after reaching the test goal need to be explicitly determined. The goal of this thesis is to apply CPAch",
  "content_length": 20961,
  "method": "requests",
  "crawl_time": "2025-12-01 13:52:41"
}