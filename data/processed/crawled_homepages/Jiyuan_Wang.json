{
  "name": "Jiyuan Wang",
  "homepage": "https://www.cs.tulane.edu/~wjiyuan",
  "status": "success",
  "content": "Jiyuan Wang I'm currently an Assistant Professor at Tulane University. Before that, I was an applied scientist at AWS identity. I earned my PhD in Computer Science Department at University of California, Los Angeles. I am designing testing and debug method for big data analytic and FPGA. I was a member of SOLAR group and co-advised by Professor Miryung Kim and Professor Harry Xu. Finished my defense! Check my defense slide if you are insterested slide I joined the Department of Computer Science at Tulane University as an Assistant Professsor in the Fall 2025. I'm looking for students who want to work on Softwrae Engineering and Quantum Computing. Feel free to email me if you are insterested! Published & Forthcoming Papers DuoReduce: Bug Isolation for Multi-Layer Extensible Compilation By Jiyuan Wang, Yuxin Qiu, Ben Limpanukorn, Hong Jin Kang, Qian Zhang, Miryung Kim The 33rd ACM International Conference on the Foundations of Software Engineering, FSE 2025. Abstract In recent years, the MLIR platform has had explosive growth due to the need of building extensible deep learning compilers and hardware accelerator compilers. Such examples include Triton, CIRCT, and ONNX-MLIR. MLIR compilers introduce significant complexities in localizing bugs or inefficiencies because of their layered optimization and transformation process with compilation passes. While existing delta debugging techniques can be used to identify a minimum subset of IR code that reproduces a given bug symptom, their naive application to MLIR is time-consuming, because real-world MLIR compilers usually involve a large number of compilation passes and compiler developers must also identify a minimized set of relevant compilation passes simultaneously, in order to reduce the footprint of MLIR compiler code to be inspected for a bug fix. We propose DuoReduce, a dual-dimensional reduction approach for MLIR bug localization. DuoReduce leverages three key ideas in tandem to design an efficient MLIR debugger. First, DuoReduce reduces the bug-irrelevant compilation passes by identifying ordering dependencies among different compilation passes. Second, DuoReduce uses MLIR-semantics aware transformations to expedite IR code reduction. Finally, DuoReduce leverages cross-dependence between the IR code dimension and the compilation pass dimension by accounting for which IR code segments are related to which compilation passes to reduce the unused passes. Experiments with three large-scale MLIR compiler projects find that DuoReduce outperforms syntax-aware reducers such as Perses and Vulcan in terms of IR code reduction by 31.6% and 21.5% respectively. If one uses these reducers by enumerating all possible compilation passes (on average 18 passes), it could take up to 145 hours. By identifying ordering dependencies among compilation passes, DuoReduce reduces this time to 9.5 minutes. By identifying which compilation passes are unused for compiling reduced IR code, DuoReduce reduces the number of passes by 14.6%. This translates to not needing to examine 281 lines of MLIR compiler code on average to fix the bugs. DuoReduce has the potential to significantly reduce debugging effort in multi-layer extensible compilers, which serves as an important basis for the current landscape of machine learning and hardware accelerators. Replication files Data & code for replication Fuzzing MLIR Compilers with Custom Mutation Synthesis By Ben Limpanukorn, Jiyuan Wang, Hong Jin Kang, Zitong Zhou, Miryung Kim The 47th IEEE/ACM International Conference on Software Engineering, ICSE 2025. Abstract Compiler technologies in deep learning and domain-specific hardware acceleration are increasingly adopting extensible compiler frameworks such as Multi-Level Intermediate Representation (MLIR) to facilitate more efficient development. With MLIR, compiler developers can easily define their own custom IRs in the form of MLIR dialects. However, the diversity and rapid evolution of such custom IRs make it impractical to manually write a custom test generator for each dialect. To address this problem, we design a new test generator called SYNTHFUZZ that combines grammar-based fuzzing with custom mutation synthesis. The key essence of SYNTHFUZZ is two fold: (1) It automatically infers parameterized context-dependent custom mutations from existing test cases. (2) It then concretizes the mutation’s content depending on the target context and reduces the chance of inserting invalid edits by performing k-ancestor and prefix/postfix matching. It obviates the need to manually define custom mutation operators for each dialect. We compare SYNTHFUZZ to three baselines: Grammarinator—a grammar-based fuzzer without custom mutations, MLIRSmith—a custom test generator for MLIR core dialects, and NeuRI—a custom test generator for ML models with parameterization of tensor shapes. We conduct this comprehensive comparison on four different MLIR projects. Each project defines a new set of MLIR dialects where manually writing a custom test generator would take weeks of effort. Our evaluation shows that SYNTHFUZZ on average improves MLIR dialect pair coverage by 1.75×, which increases branch coverage by 1.22×. Further, we show that our context dependent custom mutation increases the proportion of valid tests by up to 1.11×, indicating that SYNTHFUZZ correctly concretizes its parameterized mutations with respect to the target context. Parameterization of the mutations reduces the fraction of tests violating the base MLIR constraints by 0.57×, increasing the time spent fuzzing dialect-specific code Replication files Data & code for replication Leveraging Hardware Probes and Optimizations for Accelerating Fuzz Testing of Heterogeneous Applications By Jiyuan Wang, Qian Zhang, Hongbo Rong, Guoqing Harry Xu, Miryung Kim The 31st ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering, ESEC/FSE 2023. Abstract There is a growing interest in the computer architecture community to incorporate heterogeneity and specialization to improve performance. Developers can create heterogeneous applications that consist of both host code and kernel code, where compute-intensive kernels can be offloaded from CPU to hardware accelerators. Testing such applications on real heterogeneous architectures is extremely challenging as kernels are black boxes, providing no information about the kernels’ internal execution to diagnose issues such as silent hangs or unexpected results. Additionally, inputs for heterogeneous applications are often large matrices, leading to a vast search space for identifying bug-revealing inputs. We propose a novel fuzz testing technique, HFuzz, to enable efficient testing on real heterogeneous architectures. HFuzz aims to increase both the observability of hardware kernels and testing efficiency through a three-pronged approach. First, HFuzz automatically generates test guidance by inserting device-side in-kernel hardware probes in addition to host-side software monitors. Second, it performs rapid input space exploration by offloading computeintensive input mutations to hardware kernels. Third, HFuzz parallelizes fuzzing and enables fast on-chip memory access, by utilizing four FPGA-level optimizations including loop unrolling, shannonization, data preloading, and dynamic kernel sharing. We evaluate HFuzz on seven open-source OneAPI subjects from Intel. HFuzz speeds up fuzz testing by 4.7× with HW-accelerated input space exploration. By incorporating HW probes in tandem with SW monitors, HFuzz finds 33 defects within 4 hours and reveals 25 unique, unexpected behavior symptoms that could not be found by SW-based monitoring alone. HFuzz is the first to design hardware optimizations to accelerate fuzz testing. Replication files Data & code for replication HeteroGen: Transpiling C to Heterogeneous HLS Code with Automated Test Generation and Program Repair By Qian Zhang, Jiyuan Wang, Guoqing Harry Xu, Miryung Kim The 22nd Conference on Architectural Support for Programming Languages and Operating Systems, ASPLOS 2022. Abstract Despite the trend of incorporating heterogeneity and specialization in hardware, the development of heterogeneous applications is limited to a handful of engineers with deep hardware expertise. We propose HeteroGen that takes C/C++ code as input and automatically generates an HLS version with test behavior preservation and better performance. Key to the success of HeteroGen is adapting the idea of search-based program repair to the heterogeneous computing domain, while addressing two technical challenges. First, the turn-around time of HLS compilation and simulation is much longer than the usual C/C++ compilation and execution time; therefore, HeteroGen applies pattern-oriented program edits guided by common fix patterns and their dependences. Second, behavior and performance checking requires testing, but test cases are often unavailable. Thus, HeteroGen auto-generates test inputs suitable for checking C to HLS-C conversion errors, while providing high branch coverage for the original C code. Replication files Data & code for replication QDiff: Differential Testing for Quantum Software Stacks By Jiyuan Wang, Qian Zhang, Guoqing Harry Xu, Miryung Kim The 36th IEEE/ACM International Conference on Automated Software Engineering, ASE 2021. SIGSOFT reseach highlight! Abstract The past few years have witnessed the proliferation of quantum software stacks (QSS) developed in response to rapid hardware advances in quantum computing. A QSS includes a quantum programming language, an optimizing compiler that compiles a quantum algorithm expressed in a high-level language into quantum gate instructions, a quantum simulator that emu- lates these instructions on a classical device, the control software that turns circuits into analog signals sent to the quantum computer, and execution on very expensive quantum hardware. In comparison to traditional compil",
  "content_length": 15178,
  "method": "requests",
  "crawl_time": "2025-12-01 13:31:24"
}